// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

contract PersonalBank {


    // owner of bank account (this contract)
    address owner;

    // map for all the hashes used
    mapping(bytes32 => bool) HashesUsed;
    
    constructor() payable {
        // set owner on construct
        owner = msg.sender;
    }
    


    // withdraw check function input param generated by the js file
    function cashCheque(address payable to, uint256 amount, bytes32 r, bytes32 s, uint8 v, bytes32 nonce) public {

        // Recipient and amount hash plus contract address and nonce generated by the sign-cheque.js (recipient)
        bytes32 Hash = keccak256(abi.encodePacked(to, amount, address(this)));

        // assure that the check is unused
        require(HashesUsed[Hash] == false, "check already used");

        // if passed requirement, set the target hash to true
        HashesUsed[Hash] = true;


        // \x19 prefix ensures the user is signing a signature instead of a potential transaction
        // hash the recipient and amount hash with the sign message
        bytes32 messageHash2 = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", Hash));


        // requre the decoded message to match the owner address of this contract
        // ecrecover is a verification function for signatures
        require(ecrecover(messageHash2, v, r, s) == owner, "bad signature");
        


        // transfer the fund to the recipient
        to.transfer(amount);
    }


    // receive function (reacts to receive ether)
    receive() external payable {}

    function payContract() public payable{

    }

}

// solve these 2 problems

// Replay attacks: 
// A user could cash a cheque multiple times and therefore receive more ETH than intended.
// solution: 
// create a map of all hashes of issued checks and verifies there is no replays


// Cross-contract spends: 
// If there are multiple banks using the same protocol, 
// then a cheque meant for one bank could be used on any or all of the other banks, 
// which was probably not intended.
// solution:
// include the contract address in the hash
// include a nonce generated by the recipient in the hash